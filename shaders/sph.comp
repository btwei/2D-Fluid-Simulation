#version 450 core

layout(local_size_x = 256) in;

struct Particle {
    vec4 position;
    vec4 velocity;
    vec2 properties;
};

layout(std430, binding = 0) buffer particleBuffer {
    Particle particles[];
};

layout(std430, binding = 1) buffer gridParticleStartBuffer {
    uint particleStart[];
};

layout(std430, binding = 2) buffer gridParticleDataBuffer {
    uint particleNext[];
};

uniform float h;
float mass = 1.0; /* Mass per particle      */
float k = 10000;  /* Gas Stiffness Constant */
float p0 = 1000;  /* Rest Density           */

float pi = 3.1415926538;

ivec3 getCellIndex(vec3 position);
uint flattenCellIndex(ivec3 cellIndex);
float poly6(float distance, float h);

uint maxUint = 0xffffffffu;
vec3 gridMin = vec3(-1, -1, -1);
vec3 gridMax = vec3( 1,  1,  1);

vec3 cellMin = vec3( 0,  0,  0);
vec3 cellMax = vec3(10, 10, 10);

const ivec3 neighborOffsets[27] = {
    ivec3(-1, -1, -1), ivec3(-1, -1, 0), ivec3(-1, -1, 1),
    ivec3(-1,  0, -1), ivec3(-1,  0, 0), ivec3(-1,  0, 1),
    ivec3(-1,  1, -1), ivec3(-1,  1, 0), ivec3(-1,  1, 1),
    ivec3( 0, -1, -1), ivec3( 0, -1, 0), ivec3( 0, -1, 1),
    ivec3( 0,  0, -1), ivec3( 0,  0, 0), ivec3( 0,  0, 1),
    ivec3( 0,  1, -1), ivec3( 0,  1, 0), ivec3( 0,  1, 1),
    ivec3( 1, -1, -1), ivec3( 1, -1, 0), ivec3( 1, -1, 1),
    ivec3( 1,  0, -1), ivec3( 1,  0, 0), ivec3( 1,  0, 1),
    ivec3( 1,  1, -1), ivec3( 1,  1, 0), ivec3( 1,  1, 1),
};

void main(){
    uint idx = gl_GlobalInvocationID.x;

    //Initialize particleStarts and particleNexts to a special value
    if(idx < particleStart.length()) particleStart[idx] = maxUint;
    if(idx < particleNext.length()) particleNext[idx] = maxUint;

    if(idx >= particles.length()) return;

    memoryBarrier();

    //Calculate this particle's cell index
    ivec3 cellIndex = getCellIndex(particles[idx].position.xyz);
    uint flatCellIndex = flattenCellIndex(cellIndex);

    //Go to the listStart buffer and try to add itself to that grid space
    uint swapVal = atomicCompSwap(particleStart[flatCellIndex], maxUint, idx);

    while(swapVal != maxUint) {
        //Traverse the list Buffer
        swapVal = atomicCompSwap(particleNext[swapVal], maxUint, idx);
    }

    memoryBarrier();

    //calculate density and pressure from nearest neighbors

    float density = 0;

    for (int n = 0; n < 27; ++n) {
        ivec3 neighborCell = cellIndex + neighborOffsets[n];

        // Check if the neighbor cell is within grid bounds
        if (neighborCell.x >= 0 && neighborCell.x < cellMax.x &&
            neighborCell.y >= 0 && neighborCell.y < cellMax.y &&
            neighborCell.z >= 0 && neighborCell.z < cellMax.z) {
            
            // Access particles in this neighbor cell
            uint flatNeighborCellIndex = flattenCellIndex(neighborCell);

            // Fetch particles from this cell and process them
            uint neighborParticle = particleStart[flatNeighborCellIndex];

            while (neighborParticle != maxUint){
                //process particle
                float distance = length(particles[idx].position.xyz - particles[neighborParticle].position.xyz);

                if(distance < h){
                    density += mass * poly6(distance, h);
                }

                //move onto the next particle
                neighborParticle = particleNext[neighborParticle];
            }
        }
    }

    float pressure = k * (density - p0);

    //write density and pressure to shared memory
    particles[idx].properties.x = density;
    particles[idx].properties.y = pressure;

    memoryBarrier();
}

ivec3 getCellIndex(vec3 position) {
    return ivec3(floor((position + 1.0f) / 0.2f));
}

uint flattenCellIndex(ivec3 cellIndex) {
    return uint(cellIndex.x + 10 * (cellIndex.y + 10 * cellIndex.z));
}

float poly6(float r, float h) {
    return 315 / 64 / pi / pow(h, 9) * pow(h*h - r*r, 3);
}